require('dotenv').config()
const express = require('express')
const { MongoClient, ObjectId } = require('mongodb')
const cors = require('cors')

const app = express()
const PORT = process.env.PORT || 3001

// Middleware
app.use(cors())
app.use(express.json())

// Configuration MongoDB
const mongoUrl = process.env.MONGO_URI || 'mongodb://localhost:27017'
const dbName = 'maisoncleo'

// Configuration WooCommerce (utiliser les variables existantes)
const WOOCOMMERCE_URL = process.env.VITE_WORDPRESS_URL || 'https://maisoncleo.com'
const WOOCOMMERCE_CONSUMER_KEY = process.env.VITE_WORDPRESS_CONSUMER_KEY
const WOOCOMMERCE_CONSUMER_SECRET = process.env.VITE_WORDPRESS_CONSUMER_SECRET

console.log('üîç URL MongoDB configur√©e:', mongoUrl)
console.log('üîç Variables d\'environnement:', {
  MONGO_URI: process.env.MONGO_URI ? '‚úÖ D√©finie' : '‚ùå Manquante',
  WOOCOMMERCE_URL: WOOCOMMERCE_URL ? '‚úÖ D√©finie' : '‚ùå Manquante',
  WOOCOMMERCE_CONSUMER_KEY: WOOCOMMERCE_CONSUMER_KEY ? '‚úÖ D√©finie' : '‚ùå Manquante',
  WOOCOMMERCE_CONSUMER_SECRET: WOOCOMMERCE_CONSUMER_SECRET ? '‚úÖ D√©finie' : '‚ùå Manquante',
  PORT: process.env.PORT || '3001 (d√©faut)'
})

let db

// Connexion √† MongoDB
async function connectToMongo() {
  try {
    const client = new MongoClient(mongoUrl)
    await client.connect()
    db = client.db(dbName)
    
    // Cr√©er les collections et index n√©cessaires
    await createCollectionsAndIndexes()
    
    console.log('‚úÖ Connect√© √† MongoDB Atlas')
  } catch (error) {
    console.error('‚ùå Erreur de connexion MongoDB:', error)
  }
}

// Cr√©er les collections et index
async function createCollectionsAndIndexes() {
  try {
    // Collection des commandes synchronis√©es
    const ordersCollection = db.collection('orders_sync')
    await ordersCollection.createIndex({ order_id: 1 }, { unique: true })
    await ordersCollection.createIndex({ order_date: -1 })
    
    // Collection des articles de commande
    const itemsCollection = db.collection('order_items')
    await itemsCollection.createIndex({ order_id: 1 })
    await itemsCollection.createIndex({ order_id: 1, line_item_id: 1 }, { unique: true })
    
    // Collection des statuts de production
    const statusCollection = db.collection('production_status')
    await statusCollection.createIndex({ order_id: 1, line_item_id: 1 }, { unique: true })
    await statusCollection.createIndex({ production_type: 1 })
    await statusCollection.createIndex({ status: 1 })

    // Collection des images produits pour √©viter les probl√®mes CORS
    const imagesCollection = db.collection('product_images')
    await imagesCollection.createIndex({ product_id: 1 }, { unique: true })
    
    // Collection des tricoteuses
    const tricoteusesCollection = db.collection('tricoteuses')
    await tricoteusesCollection.createIndex({ firstName: 1 })
    await tricoteusesCollection.createIndex({ createdAt: -1 })
    
    console.log('‚úÖ Collections et index cr√©√©s')
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation collections:', error)
  }
}

// Routes API

// GET /api/woocommerce/products/:productId/permalink - R√©cup√©rer le permalink d'un produit
app.get('/api/woocommerce/products/:productId/permalink', async (req, res) => {
  try {
    const { productId } = req.params
    
    if (!WOOCOMMERCE_CONSUMER_KEY || !WOOCOMMERCE_CONSUMER_SECRET) {
      return res.status(500).json({ 
        error: 'Configuration WooCommerce manquante',
        message: 'Veuillez configurer WOOCOMMERCE_CONSUMER_KEY et WOOCOMMERCE_CONSUMER_SECRET'
      })
    }
    
    const authParams = `consumer_key=${WOOCOMMERCE_CONSUMER_KEY}&consumer_secret=${WOOCOMMERCE_CONSUMER_SECRET}`
    const url = `${WOOCOMMERCE_URL}/wp-json/wc/v3/products/${productId}?${authParams}&_fields=id,permalink`
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
      },
      // Timeout de 5 secondes
      signal: AbortSignal.timeout(5000)
    })
    
    if (!response.ok) {
      if (response.status === 404) {
        return res.status(404).json({ error: 'Produit non trouv√©' })
      } else if (response.status >= 500) {
        return res.status(502).json({ error: 'Erreur serveur WooCommerce' })
      } else {
        return res.status(response.status).json({ error: `Erreur HTTP: ${response.status}` })
      }
    }
    
    const product = await response.json()
    const permalink = product?.permalink || null
    
    if (!permalink) {
      return res.status(404).json({ error: 'Permalink non trouv√© pour ce produit' })
    }
    
    res.json({ 
      success: true,
      product_id: parseInt(productId),
      permalink: permalink
    })
    
  } catch (error) {
    if (error.name === 'TimeoutError') {
      return res.status(408).json({ error: 'Timeout lors de la r√©cup√©ration du permalink' })
    }
    
    console.error('Erreur GET /woocommerce/products/:productId/permalink:', error)
    res.status(500).json({ error: 'Erreur serveur interne' })
  }
})

// GET /api/woocommerce/products/permalink/batch - R√©cup√©rer les permalinks de plusieurs produits
app.post('/api/woocommerce/products/permalink/batch', async (req, res) => {
  try {
    const { productIds } = req.body
    
    if (!Array.isArray(productIds) || productIds.length === 0) {
      return res.status(400).json({ error: 'Liste de productIds invalide' })
    }
    
    if (!WOOCOMMERCE_CONSUMER_KEY || !WOOCOMMERCE_CONSUMER_SECRET) {
      return res.status(500).json({ 
        error: 'Configuration WooCommerce manquante',
        message: 'Veuillez configurer WOOCOMMERCE_CONSUMER_KEY et WOOCOMMERCE_CONSUMER_SECRET'
      })
    }
    
    const authParams = `consumer_key=${WOOCOMMERCE_CONSUMER_KEY}&consumer_secret=${WOOCOMMERCE_CONSUMER_SECRET}`
    const results = []
    const errors = []
    
    // Traiter les produits en parall√®le avec un d√©lai pour √©viter la surcharge
    for (let i = 0; i < productIds.length; i++) {
      const productId = productIds[i]
      
      try {
        // D√©lai entre les requ√™tes pour √©viter la surcharge
        if (i > 0) {
          await new Promise(resolve => setTimeout(resolve, 100))
        }
        
        const url = `${WOOCOMMERCE_URL}/wp-json/wc/v3/products/${productId}?${authParams}&_fields=id,permalink`
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
          },
          signal: AbortSignal.timeout(3000)
        })
        
        if (response.ok) {
          const product = await response.json()
          if (product?.permalink) {
            results.push({
              product_id: parseInt(productId),
              permalink: product.permalink
            })
          }
        } else {
          errors.push({
            product_id: parseInt(productId),
            error: `HTTP ${response.status}`,
            status: response.status
          })
        }
      } catch (error) {
        errors.push({
          product_id: parseInt(productId),
          error: error.message,
          type: error.name
        })
      }
    }
    
    res.json({ 
      success: true,
      results: results,
      errors: errors,
      total_processed: productIds.length,
      total_success: results.length,
      total_errors: errors.length
    })
    
  } catch (error) {
    console.error('Erreur POST /woocommerce/products/permalink/batch:', error)
    res.status(500).json({ error: 'Erreur serveur interne' })
  }
})

// POST /api/sync/orders - Synchroniser les commandes WooCommerce
app.post('/api/sync/orders', async (req, res) => {
  try {
    addSyncLog('üîÑ D√©but de la synchronisation des commandes', 'info')
    
    // R√©cup√©rer les commandes depuis WooCommerce
    let woocommerceOrders = []
    
    if (WOOCOMMERCE_CONSUMER_KEY && WOOCOMMERCE_CONSUMER_SECRET) {
      try {
        const authParams = `consumer_key=${WOOCOMMERCE_CONSUMER_KEY}&consumer_secret=${WOOCOMMERCE_CONSUMER_SECRET}`
        const url = `${WOOCOMMERCE_URL}/wp-json/wc/v3/orders?${authParams}&per_page=50&status=processing,completed&orderby=date&order=desc`
        
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
          },
          signal: AbortSignal.timeout(10000)
        })
        
        if (response.ok) {
          woocommerceOrders = await response.json()
        } else {
          addSyncLog(`‚ö†Ô∏è Erreur HTTP ${response.status} lors de la r√©cup√©ration des commandes`, 'warning')
        }
      } catch (error) {
        addSyncLog(`‚ö†Ô∏è Erreur lors de la r√©cup√©ration des commandes WooCommerce: ${error.message}`, 'error')
      }
    } else {
      addSyncLog('‚ö†Ô∏è Cl√©s WooCommerce non configur√©es, synchronisation impossible', 'error')
      return res.status(500).json({ 
        error: 'Configuration WooCommerce manquante',
        message: 'Veuillez configurer les cl√©s API WooCommerce'
      })
    }
    
    if (woocommerceOrders.length === 0) {
      addSyncLog('‚ÑπÔ∏è Aucune commande √† synchroniser', 'info')
      return res.json({
        success: true,
        message: 'Aucune nouvelle commande',
        results: {
          ordersCreated: 0,
          ordersUpdated: 0,
          itemsCreated: 0,
          itemsUpdated: 0
        }
      })
    }
    
    // Synchroniser les commandes
    addSyncLog('üîÑ D√©but de la synchronisation avec la base de donn√©es...', 'info')
    const syncResults = await syncOrdersToDatabase(woocommerceOrders)
    
    // Afficher le message appropri√© selon le r√©sultat
    if (syncResults.ordersCreated === 0 && syncResults.itemsCreated === 0) {
      addSyncLog('‚ÑπÔ∏è Aucune nouvelle commande √† traiter', 'info')
    } else {
    addSyncLog('‚úÖ Synchronisation termin√©e avec succ√®s', 'success')
    }
    
    res.json({
      success: true,
      message: 'Synchronisation r√©ussie',
      results: syncResults
    })
    
  } catch (error) {
    addSyncLog(`‚ùå Erreur lors de la synchronisation: ${error.message}`, 'error')
    res.status(500).json({ 
      error: 'Erreur lors de la synchronisation',
      message: error.message 
    })
  }
})

// GET /api/orders/search/:orderNumber - Rechercher une commande par num√©ro
app.get('/api/orders/search/:orderNumber', async (req, res) => {
  try {
    const { orderNumber } = req.params
    
    // Rechercher la commande par num√©ro
    const order = await db.collection('orders_sync').findOne({ 
      order_number: orderNumber 
    })
    
    if (!order) {
      return res.status(404).json({ 
        success: false, 
        message: 'Commande non trouv√©e' 
      })
    }
    
    // R√©cup√©rer les articles de la commande
    const itemsCollection = db.collection('order_items')
    const items = await itemsCollection.find({ 
      order_id: order.order_id 
    }).toArray()
    
    if (items.length === 0) {
      return res.status(404).json({ 
        success: false, 
        message: 'Aucun article trouv√© pour cette commande' 
      })
    }
    
    // R√©cup√©rer les statuts de production pour chaque article
    const statusCollection = db.collection('production_status')
    const itemsWithStatus = await Promise.all(items.map(async (item) => {
      const status = await statusCollection.findOne({
        line_item_id: item.line_item_id
      })
      
      return {
        ...item,
        production_status: status || {
          status: 'a_faire',
          production_type: null,
          assigned_to: null
        }
      }
    }))
    
    // D√©terminer le type de production principal (le plus fr√©quent ou le premier trouv√©)
    let mainProductionType = null
    const productionStatuses = itemsWithStatus
      .map(item => item.production_status)
      .filter(status => status && status.production_type)
    
    if (productionStatuses.length > 0) {
      // Compter les types de production
      const typeCounts = {}
      productionStatuses.forEach(status => {
        if (status.production_type) {
          typeCounts[status.production_type] = (typeCounts[status.production_type] || 0) + 1
        }
      })
      
      // Prendre le type le plus fr√©quent, sinon le premier
      if (Object.keys(typeCounts).length > 0) {
        mainProductionType = Object.entries(typeCounts).reduce((a, b) => 
          typeCounts[a[0]] > typeCounts[b[0]] ? a : b
        )[0]
      } else {
        mainProductionType = productionStatuses[0]?.production_type || null
      }
    }
    
    // Construire la r√©ponse avec les informations de production
    const orderWithProduction = {
      ...order,
      production_type: mainProductionType,
      line_item_id: items[0].line_item_id,
      items: itemsWithStatus,
      all_production_statuses: productionStatuses // Pour debug
    }
    
    // Log pour debug
    console.log(`üîç Recherche commande ${orderNumber}:`, {
      order_id: order.order_id,
      total_items: itemsWithStatus.length,
      production_type: mainProductionType,
      items_with_status: itemsWithStatus.map(item => ({
        line_item_id: item.line_item_id,
        product_name: item.product_name,
        has_production_status: !!item.production_status,
        production_type: item.production_status?.production_type,
        status: item.production_status?.status
      }))
    })
    
    res.json({ 
      success: true, 
      order: orderWithProduction 
    })
  } catch (error) {
    console.error('Erreur GET /orders/search/:orderNumber:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// PUT /api/orders/:orderId/status - Mettre √† jour le statut d'une commande
app.put('/api/orders/:orderId/status', async (req, res) => {
  try {
    const { orderId } = req.params
    const { status: newStatus } = req.body
    
    if (!newStatus) {
      return res.status(400).json({ 
        success: false, 
        error: 'Statut requis' 
      })
    }
    
    // Mettre √† jour le statut dans la collection production_status
    const statusCollection = db.collection('production_status')
    const result = await statusCollection.updateMany(
      { order_id: parseInt(orderId) },
      { 
        $set: { 
          status: newStatus,
          updated_at: new Date()
        } 
      }
    )
    
    if (result.matchedCount === 0) {
      return res.status(404).json({ 
        success: false, 
        error: 'Aucune commande trouv√©e avec cet ID' 
      })
    }
    
    console.log(`‚úÖ Statut mis √† jour pour la commande ${orderId}: ${newStatus}`)
    
    res.json({ 
      success: true, 
      message: `Statut mis √† jour pour ${result.modifiedCount} article(s)`,
      orderId: parseInt(orderId),
      newStatus,
      modifiedCount: result.modifiedCount
    })
    
  } catch (error) {
    console.error('Erreur PUT /orders/:orderId/status:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// GET /api/orders - R√©cup√©rer toutes les commandes avec articles et statuts
app.get('/api/orders', async (req, res) => {
  try {
    const ordersCollection = db.collection('orders_sync')
    const itemsCollection = db.collection('order_items')
    const statusCollection = db.collection('production_status')
    
    // R√©cup√©rer toutes les commandes
    const orders = await ordersCollection.find({}).sort({ order_date: 1 }).toArray()
    
    // Pour chaque commande, r√©cup√©rer les articles et statuts
    const ordersWithDetails = await Promise.all(orders.map(async (order) => {
      const items = await itemsCollection.find({ order_id: order.order_id }).toArray()
      
      // Ajouter les statuts de production √† chaque article
      const itemsWithStatus = await Promise.all(items.map(async (item) => {
        const status = await statusCollection.findOne({
          order_id: order.order_id,
          line_item_id: item.line_item_id
        })
        
        return {
          ...item,
          production_status: status || {
            status: 'a_faire',
            production_type: null,
            assigned_to: null
          }
        }
      }))
      
      return {
        ...order,
        items: itemsWithStatus
      }
    }))
    
    res.json({ orders: ordersWithDetails })
  } catch (error) {
    console.error('Erreur GET /orders:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// GET /api/orders/production/:type - R√©cup√©rer les commandes par type de production
app.get('/api/orders/production/:type', async (req, res) => {
  try {
    const { type } = req.params // 'couture' ou 'maille'
    const statusCollection = db.collection('production_status')
    const itemsCollection = db.collection('order_items')
    
    // R√©cup√©rer les articles assign√©s √† ce type de production
    const assignedItems = await statusCollection.find({
      production_type: type
    }).toArray()
    
    console.log(`üìä Articles trouv√©s pour ${type}:`, assignedItems.length)
    
    // Si aucun article n'est dispatch√©, essayer de dispatcher automatiquement
    if (assignedItems.length === 0) {
      console.log(`üîÑ Aucun article dispatch√© pour ${type}, tentative de dispatch automatique...`)
      
      // R√©cup√©rer tous les articles
      const allItems = await itemsCollection.find({}).toArray()
      console.log(`üìã Total d'articles en base:`, allItems.length)
      
      // Dispatcher automatiquement les articles non dispatch√©s
      for (const item of allItems) {
        const existingStatus = await statusCollection.findOne({
          order_id: item.order_id,
          line_item_id: item.line_item_id
        })
        
        if (!existingStatus) {
          const productionType = determineProductionType(item.product_name)
          console.log(`üìã Dispatch automatique: ${item.product_name} -> ${productionType}`)
          
          if (productionType === type) {
            const productionStatus = {
              order_id: parseInt(item.order_id),
              line_item_id: parseInt(item.line_item_id),
              status: 'a_faire',
              production_type: productionType,
              assigned_to: null,
              created_at: new Date(),
              updated_at: new Date()
            }
            
            await statusCollection.insertOne(productionStatus)
            assignedItems.push(productionStatus)
          }
        }
      }
      
      console.log(`‚úÖ Articles dispatch√©s pour ${type}:`, assignedItems.length)
    }
    
    // R√©cup√©rer les d√©tails des commandes et articles
    const ordersWithDetails = await Promise.all(assignedItems.map(async (status) => {
      const order = await db.collection('orders_sync').findOne({ order_id: status.order_id })
      const item = await db.collection('order_items').findOne({
        order_id: status.order_id,
        line_item_id: status.line_item_id
      })
      
      // Retourner la structure attendue par le frontend
      return {
        ...order,
        items: [{
          ...item,
          production_status: status
        }]
      }
    }))
    
    // Trier les commandes par date (anciennes vers r√©centes)
    ordersWithDetails.sort((a, b) => new Date(a.order_date) - new Date(b.order_date))
    
    res.json({ orders: ordersWithDetails })
  } catch (error) {
    console.error('Erreur GET /orders/production/:type:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// POST /api/production/dispatch - Dispatcher un article vers la production
app.post('/api/production/dispatch', async (req, res) => {
  try {
    const { order_id, line_item_id, production_type, assigned_to } = req.body
    
    if (!order_id || !line_item_id || !production_type) {
      return res.status(400).json({ error: 'Param√®tres manquants' })
    }
    
    const statusCollection = db.collection('production_status')
    
    const result = await statusCollection.updateOne(
      {
        order_id: parseInt(order_id),
        line_item_id: parseInt(line_item_id)
      },
      {
        $set: {
          order_id: parseInt(order_id),
          line_item_id: parseInt(line_item_id),
          status: 'en_cours',
          production_type,
          assigned_to: assigned_to || null,
          updated_at: new Date()
        }
      },
      { upsert: true }
    )
    
    res.json({ 
      success: true, 
      message: 'Article dispatch√© vers la production',
      result 
    })
  } catch (error) {
    console.error('Erreur POST /production/dispatch:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// PUT /api/production/redispatch - Redispatch un article vers un autre type de production
app.put('/api/production/redispatch', async (req, res) => {
  try {
    const { order_id, line_item_id, new_production_type } = req.body
    
    if (!order_id || !line_item_id || !new_production_type) {
      return res.status(400).json({ error: 'Param√®tres manquants' })
    }
    
    const statusCollection = db.collection('production_status')
    
    // V√©rifier que l'article existe
    const existingStatus = await statusCollection.findOne({
      order_id: parseInt(order_id),
      line_item_id: parseInt(line_item_id)
    })
    
    if (!existingStatus) {
      return res.status(404).json({ error: 'Article non trouv√©' })
    }
    
    // Mettre √† jour le type de production
    const result = await statusCollection.updateOne(
      {
        order_id: parseInt(order_id),
        line_item_id: parseInt(line_item_id)
      },
      {
        $set: {
          production_type: new_production_type,
          updated_at: new Date()
        }
      }
    )
    
    res.json({ 
      success: true, 
      message: `Article redispatch√© vers ${new_production_type}`,
      result 
    })
  } catch (error) {
    console.error('Erreur PUT /production/redispatch:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// PUT /api/production/status - Mettre √† jour le statut de production
app.put('/api/production/status', async (req, res) => {
  try {
    const { order_id, line_item_id, status, notes } = req.body
    
    if (!order_id || !line_item_id || !status) {
      return res.status(400).json({ error: 'Param√®tres manquants' })
    }
    
    const statusCollection = db.collection('production_status')
    
    const result = await statusCollection.updateOne(
      {
        order_id: parseInt(order_id),
        line_item_id: parseInt(line_item_id)
      },
      {
        $set: {
          status,
          notes: notes || null,
          updated_at: new Date()
        }
      }
    )
    
    if (result.matchedCount === 0) {
      return res.status(404).json({ error: 'Article non trouv√©' })
    }
    
    res.json({ 
      success: true, 
      message: 'Statut mis √† jour',
      result 
    })
  } catch (error) {
    console.error('Erreur PUT /production/status:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// Fonctions utilitaires

// Fonction pour synchroniser toutes les commandes vers la base de donn√©es
async function syncOrdersToDatabase(woocommerceOrders) {
  const syncResults = {
    ordersCreated: 0,
    ordersUpdated: 0,
    itemsCreated: 0,
    itemsUpdated: 0,
    errors: []
  }
  
  addSyncLog(`üîÑ Traitement de ${woocommerceOrders.length} commandes (cr√©ation/mise √† jour)...`, 'info')
  
  // Traiter toutes les commandes en upsert
  for (const order of woocommerceOrders) {
    try {
      const orderResult = await syncOrderToDatabase(order)
      if (orderResult.created) {
        syncResults.ordersCreated++
      } else if (orderResult.updated) {
        syncResults.ordersUpdated++
      }

      for (const item of order.line_items || []) {
        const itemResult = await syncOrderItem(order.id, item)
        if (itemResult.created) {
          syncResults.itemsCreated++
          // Dispatcher automatiquement uniquement les nouveaux articles
          await dispatchItemToProduction(order.id, item.id, item.name)
        } else if (itemResult.updated) {
          syncResults.itemsUpdated++
        }
      }
    } catch (error) {
      addSyncLog(`‚ùå Erreur sur la commande #${order.number}: ${error.message}`, 'error')
      syncResults.errors.push({
        orderId: order.id,
        error: error.message
      })
    }
  }
  
  addSyncLog(`üìä R√©sultats: ${syncResults.ordersCreated} commandes cr√©√©es, ${syncResults.ordersUpdated} mises √† jour, ${syncResults.itemsCreated} articles cr√©√©s, ${syncResults.itemsUpdated} mis √† jour`, 'info')
  
  // Dispatcher automatiquement les articles existants qui n'ont pas de statut de production
  if (syncResults.itemsCreated > 0) {
    addSyncLog('üîÑ Dispatch automatique des articles vers la production...', 'info')
    await dispatchExistingItemsToProduction()
  }
  
  return syncResults
}

// Fonction pour dispatcher automatiquement un article vers la production
async function dispatchItemToProduction(orderId, lineItemId, productName) {
  try {
    const statusCollection = db.collection('production_status')
    
    // D√©terminer le type de production bas√© sur le nom du produit
    const productionType = determineProductionType(productName)
    
    // Cr√©er le statut de production avec "a_faire"
    const productionStatus = {
      order_id: parseInt(orderId),
      line_item_id: parseInt(lineItemId),
      status: 'a_faire',
      production_type: productionType,
      assigned_to: null,
      created_at: new Date(),
      updated_at: new Date()
    }
    
    await statusCollection.insertOne(productionStatus)
    
    addSyncLog(`üìã Article dispatch√© vers ${productionType}`, 'info')
  } catch (error) {
    console.warn(`Erreur lors du dispatch automatique vers la production: ${error.message}`)
  }
}

// Fonction pour d√©terminer le type de production d'un produit
function determineProductionType(productName) {
  const name = productName.toLowerCase()
  
  // Seulement les mots sp√©cifiquement li√©s au tricot/maille
  const mailleKeywords = [
    'tricot√©e', 'tricot√©', 'knitted'
  ]
  
  // Si le produit contient un de ces mots ‚Üí maille, sinon ‚Üí couture
  if (mailleKeywords.some(keyword => name.includes(keyword))) {
    return 'maille'
  }
  
  return 'couture'
}

// Fonction pour dispatcher automatiquement les articles existants vers la production
async function dispatchExistingItemsToProduction() {
  try {
    const itemsCollection = db.collection('order_items')
    const statusCollection = db.collection('production_status')
    
    // R√©cup√©rer tous les articles qui n'ont pas encore de statut de production
    const itemsWithoutStatus = await itemsCollection.aggregate([
      {
        $lookup: {
          from: 'production_status',
          localField: 'line_item_id',
          foreignField: 'line_item_id',
          as: 'status'
        }
      },
      {
        $match: {
          status: { $size: 0 }
        }
      }
    ]).toArray()
    
    if (itemsWithoutStatus.length > 0) {
      addSyncLog(`üìã Dispatch de ${itemsWithoutStatus.length} articles existants...`, 'info')
      
      for (const item of itemsWithoutStatus) {
        const productionType = determineProductionType(item.product_name)
        
        const productionStatus = {
          order_id: parseInt(item.order_id),
          line_item_id: parseInt(item.line_item_id),
          status: 'a_faire',
          production_type: productionType,
          assigned_to: null,
          created_at: new Date(),
          updated_at: new Date()
        }
        
        await statusCollection.insertOne(productionStatus)
      }
      
      addSyncLog(`‚úÖ ${itemsWithoutStatus.length} articles dispatch√©s avec succ√®s`, 'success')
    }
  } catch (error) {
    console.warn(`Erreur lors du dispatch des articles existants: ${error.message}`)
  }
}

// Fonction pour synchroniser une commande vers la base de donn√©es
async function syncOrderToDatabase(order) {
  const ordersCollection = db.collection('orders_sync')
  
  // Insert-only: ne pas modifier une commande existante
  const now = new Date()
  // Extraire les infos transporteur depuis WooCommerce
  const firstShippingLine = Array.isArray(order.shipping_lines) && order.shipping_lines.length > 0 
    ? order.shipping_lines[0] 
    : null
  const shippingMethodId = firstShippingLine?.method_id || null
  const shippingMethodTitle = firstShippingLine?.method_title || null
  // D√©terminer le transporteur (DHL/UPS/Colissimo, etc.) en inspectant id, title et meta
  let shippingCarrier = null
  const lowerTitle = (shippingMethodTitle || '').toLowerCase()
  const lowerId = (shippingMethodId || '').toLowerCase()
  const metaValues = (firstShippingLine?.meta_data || [])
    .map(m => `${m?.key || ''} ${m?.value || ''}`.toLowerCase())
    .join(' ')
  if (/(dhl)/.test(lowerTitle) || /(dhl)/.test(lowerId) || /(dhl)/.test(metaValues)) {
    shippingCarrier = 'DHL'
  } else if (/(ups)/.test(lowerTitle) || /(ups)/.test(lowerId) || /(ups)/.test(metaValues)) {
    shippingCarrier = 'UPS'
  } else if (/(colissimo|la poste)/.test(lowerTitle) || /(colissimo|laposte)/.test(lowerId) || /(colissimo|la poste)/.test(metaValues)) {
    shippingCarrier = 'Colissimo'
  }
  // Si livraison gratuite, d√©duire UPS en France sinon DHL
  const isFreeShipping = /(free|gratuit)/.test(lowerTitle) || /(free|gratuit)/.test(lowerId)
  if (!shippingCarrier && isFreeShipping) {
    const country = (order.shipping?.country || order.billing?.country || '').toUpperCase()
    shippingCarrier = country === 'FR' ? 'UPS' : 'DHL'
  }
  const resolvedShippingTitle = shippingMethodTitle || shippingMethodId || null
  // V√©rifier si la commande existe d√©j√†
  const existing = await ordersCollection.findOne({ order_id: order.id })
  if (existing) {
    return { created: false, updated: false }
  }
  await ordersCollection.insertOne({
    order_id: order.id,
    order_number: order.number,
    order_date: new Date(order.date_created),
    customer_name: `${order.billing?.first_name || ''} ${order.billing?.last_name || ''}`.trim(),
    customer_email: order.billing?.email || null,
    customer_phone: order.billing?.phone || null,
    customer_address: `${order.billing?.address_1 || ''}, ${order.billing?.postcode || ''} ${order.billing?.city || ''}`.trim(),
    customer_country: (order.shipping?.country || order.billing?.country || null),
    customer_note: order.customer_note || '',
    status: order.status,
    total: parseFloat(order.total) || 0,
    // Champs transporteur pour l'affichage frontend
    shipping_method: shippingMethodId,
    shipping_title: resolvedShippingTitle,
    shipping_method_title: shippingMethodTitle,
    shipping_carrier: shippingCarrier,
    created_at: now,
    updated_at: now
  })
  return { created: true, updated: false }
}

async function syncOrderItem(orderId, item) {
  const itemsCollection = db.collection('order_items')
  const imagesCollection = db.collection('product_images')
  
  // Insert-only: ne pas modifier un article existant
  const existing = await itemsCollection.findOne({ order_id: orderId, line_item_id: item.id })
  if (existing) {
    return { created: false, updated: false }
  }

  // R√©cup√©rer le permalink et l'image depuis WooCommerce via notre API
  let permalink = null
  let imageUrl = null
  try {
    if (WOOCOMMERCE_CONSUMER_KEY && WOOCOMMERCE_CONSUMER_SECRET) {
      const authParams = `consumer_key=${WOOCOMMERCE_CONSUMER_KEY}&consumer_secret=${WOOCOMMERCE_CONSUMER_SECRET}`
      const url = `${WOOCOMMERCE_URL}/wp-json/wc/v3/products/${item.product_id}?${authParams}&_fields=id,permalink,images`
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
        },
        signal: AbortSignal.timeout(3000)
      })
      
      if (response.ok) {
        const product = await response.json()
        permalink = product?.permalink || null
        // R√©cup√©rer l'URL de la premi√®re image si disponible
        if (product?.images && product.images.length > 0) {
          imageUrl = product.images[0].src || null
        }
      }
    }
  } catch (error) {
    console.warn(`Erreur lors de la r√©cup√©ration des donn√©es pour le produit ${item.product_id}:`, error.message)
  }

  // T√©l√©charger et stocker l'image en base pour un acc√®s sans CORS
  if (imageUrl && item.product_id) {
    try {
      const imgResp = await fetch(imageUrl)
      if (imgResp.ok) {
        const contentType = imgResp.headers.get('content-type') || 'image/jpeg'
        const arrayBuffer = await imgResp.arrayBuffer()
        const buffer = Buffer.from(arrayBuffer)

        await imagesCollection.updateOne(
          { product_id: parseInt(item.product_id) },
          {
            $set: {
              product_id: parseInt(item.product_id),
              content_type: contentType,
              data: buffer,
              updated_at: new Date()
            },
            $setOnInsert: { created_at: new Date() }
          },
          { upsert: true }
        )
      }
    } catch (e) {
      console.warn(`Impossible de stocker l'image du produit ${item.product_id}: ${e.message}`)
    }
  }
  
  // Upsert article
  const now = new Date()
  const update = {
    $set: {
      product_name: item.name,
      product_id: item.product_id,
      variation_id: item.variation_id,
      quantity: item.quantity,
      price: parseFloat(item.price) || 0,
      permalink: permalink,
      image_url: imageUrl,
      meta_data: item.meta_data || [],
      updated_at: now
    },
    $setOnInsert: {
      order_id: orderId,
      line_item_id: item.id,
      created_at: now
    }
  }
  const result = await itemsCollection.updateOne({ order_id: orderId, line_item_id: item.id }, update, { upsert: true })
  const created = result.upsertedCount === 1
  const updated = !created && result.matchedCount === 1 && result.modifiedCount > 0
  return { created, updated }
}

// Endpoint pour servir les images stock√©es (√©vite les CORS)
app.get('/api/images/:productId', async (req, res) => {
  try {
    const { productId } = req.params
    const imagesCollection = db.collection('product_images')
    const doc = await imagesCollection.findOne({ product_id: parseInt(productId) })

    if (!doc || !doc.data) {
      return res.status(404).json({ error: 'Image non trouv√©e' })
    }

    res.setHeader('Content-Type', doc.content_type || 'image/jpeg')
    res.setHeader('Cache-Control', 'public, max-age=604800, immutable')
    return res.end(doc.data.buffer)
  } catch (error) {
    console.error('Erreur GET /api/images/:productId:', error)
    return res.status(500).json({ error: 'Erreur serveur' })
  }
})

// Routes existantes pour la compatibilit√©
app.get('/api/production-status', async (req, res) => {
  try {
    const collection = db.collection('production_status')
    const statuses = await collection.find({}).toArray()
    res.json({ statuses })
  } catch (error) {
    console.error('Erreur GET /production-status:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// GET /api/production-status/stats - Statistiques de production
app.get('/api/production-status/stats', async (req, res) => {
  try {
    const statusCollection = db.collection('production_status')
    const ordersCollection = db.collection('orders_sync')
    const itemsCollection = db.collection('order_items')
    
    // Compter les documents dans chaque collection
    const totalStatuses = await statusCollection.countDocuments()
    const totalOrders = await ordersCollection.countDocuments()
    const totalItems = await itemsCollection.countDocuments()
    
    // Statistiques par type de production
    const statusesByType = await statusCollection.aggregate([
      {
        $group: {
          _id: '$production_type',
          count: { $sum: 1 }
        }
      }
    ]).toArray()
    
    // Statistiques par statut
    const statusesByStatus = await statusCollection.aggregate([
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 }
        }
      }
    ]).toArray()
    
    // Articles sans statut de production
    const itemsWithoutStatus = await itemsCollection.aggregate([
      {
        $lookup: {
          from: 'production_status',
          localField: 'line_item_id',
          foreignField: 'line_item_id',
          as: 'status'
        }
      },
      {
        $match: {
          status: { $size: 0 }
        }
      }
    ]).toArray()
    
    res.json({
      success: true,
      stats: {
        totalOrders,
        totalItems,
        totalStatuses,
        statusesByType,
        statusesByStatus,
        itemsWithoutStatus: itemsWithoutStatus.length,
        sampleItems: itemsWithoutStatus.slice(0, 3).map(item => ({
          id: item.line_item_id,
          name: item.product_name,
          order_id: item.order_id
        }))
      }
    })
  } catch (error) {
    console.error('Erreur GET /production-status/stats:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

app.post('/api/production-status', async (req, res) => {
  try {
    const { order_id, line_item_id, status, assigned_to } = req.body
    const collection = db.collection('production_status')
    
    const result = await collection.updateOne(
      {
        order_id: parseInt(order_id),
        line_item_id: parseInt(line_item_id)
      },
      {
        $set: {
          order_id: parseInt(order_id),
          line_item_id: parseInt(line_item_id),
          status,
          assigned_to,
          updated_at: new Date()
        }
      },
      { upsert: true }
    )
    
    res.json({ 
      success: true, 
      message: 'Statut mis √† jour',
      result 
    })
  } catch (error) {
    console.error('Erreur POST /production-status:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// PUT /api/production-status/:lineItemId/type - Mettre √† jour le type de production d'un article
app.put('/api/production-status/:lineItemId/type', async (req, res) => {
  try {
    const { lineItemId } = req.params
    const { production_type } = req.body
    
    if (!production_type) {
      return res.status(400).json({ 
        success: false, 
        error: 'Type de production requis' 
      })
    }
    
    if (!['couture', 'maille'].includes(production_type)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Type de production invalide. Doit √™tre "couture" ou "maille"' 
      })
    }
    
    // Mettre √† jour le type de production pour cet article sp√©cifique
    const statusCollection = db.collection('production_status')
    const result = await statusCollection.updateOne(
      { line_item_id: parseInt(lineItemId) },
      { 
        $set: { 
          production_type: production_type,
          updated_at: new Date()
        } 
      }
    )
    
    if (result.matchedCount === 0) {
      return res.status(404).json({ 
        success: false, 
        error: 'Aucun article trouv√© avec cet ID' 
      })
    }
    
    console.log(`‚úÖ Type de production mis √† jour pour l'article ${lineItemId}: ${production_type}`)
    
    res.json({ 
      success: true, 
      message: `Type de production mis √† jour pour l'article ${lineItemId}`,
      lineItemId: parseInt(lineItemId),
      production_type,
      modifiedCount: result.modifiedCount
    })
    
  } catch (error) {
    console.error('Erreur PUT /production-status/:lineItemId/type:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// Routes API pour les tricoteuses

// GET /api/tricoteuses - R√©cup√©rer toutes les tricoteuses
app.get('/api/tricoteuses', async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ error: 'Base de donn√©es non connect√©e' })
    }
    
    const tricoteusesCollection = db.collection('tricoteuses')
    const tricoteuses = await tricoteusesCollection
      .find({})
      .sort({ createdAt: -1 })
      .toArray()
    
    res.json({
      success: true,
      data: tricoteuses
    })
  } catch (error) {
    console.error('Erreur r√©cup√©ration tricoteuses:', error)
    res.status(500).json({ error: 'Erreur serveur interne' })
  }
})

// POST /api/tricoteuses - Cr√©er une nouvelle tricoteuse
app.post('/api/tricoteuses', async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ error: 'Base de donn√©es non connect√©e' })
    }
    
    const { firstName, color, photoUrl } = req.body
    
    if (!firstName || !firstName.trim()) {
      return res.status(400).json({ error: 'Le pr√©nom est requis' })
    }
    
    if (!color) {
      return res.status(400).json({ error: 'La couleur est requise' })
    }
    
    const tricoteusesCollection = db.collection('tricoteuses')
    
    const newTricoteuse = {
      firstName: firstName.trim(),
      color,
      photoUrl: photoUrl || '',
      createdAt: new Date(),
      updatedAt: new Date()
    }
    
    const result = await tricoteusesCollection.insertOne(newTricoteuse)
    
    res.status(201).json({
      success: true,
      data: {
        id: result.insertedId,
        ...newTricoteuse
      }
    })
  } catch (error) {
    console.error('Erreur cr√©ation tricoteuse:', error)
    res.status(500).json({ error: 'Erreur serveur interne' })
  }
})

// PUT /api/tricoteuses/:id - Modifier une tricoteuse
app.put('/api/tricoteuses/:id', async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ error: 'Base de donn√©es non connect√©e' })
    }
    
    const { id } = req.params
    const { firstName, color, photoUrl } = req.body
    
    if (!firstName || !firstName.trim()) {
      return res.status(400).json({ error: 'Le pr√©nom est requis' })
    }
    
    if (!color) {
      return res.status(400).json({ error: 'La couleur est requise' })
    }
    
    const tricoteusesCollection = db.collection('tricoteuses')
    
    const updateData = {
      firstName: firstName.trim(),
      color,
      photoUrl: photoUrl || '',
      updatedAt: new Date()
    }
    
    const result = await tricoteusesCollection.updateOne(
      { _id: new ObjectId(id) },
      { $set: updateData }
    )
    
    if (result.matchedCount === 0) {
      return res.status(404).json({ error: 'Tricoteuse non trouv√©e' })
    }
    
    res.json({
      success: true,
      data: {
        id,
        ...updateData
      }
    })
  } catch (error) {
    console.error('Erreur modification tricoteuse:', error)
    res.status(500).json({ error: 'Erreur serveur interne' })
  }
})

// DELETE /api/tricoteuses/:id - Supprimer une tricoteuse
app.delete('/api/tricoteuses/:id', async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ error: 'Base de donn√©es non connect√©e' })
    }
    
    const { id } = req.params
    const tricoteusesCollection = db.collection('tricoteuses')
    
    const result = await tricoteusesCollection.deleteOne({ _id: new ObjectId(id) })
    
    if (result.deletedCount === 0) {
      return res.status(404).json({ error: 'Tricoteuse non trouv√©e' })
    }
    
    res.json({
      success: true,
      message: 'Tricoteuse supprim√©e avec succ√®s'
    })
  } catch (error) {
    console.error('Erreur suppression tricoteuse:', error)
    res.status(500).json({ error: 'Erreur serveur interne' })
  }
})

// Variable globale pour stocker le dernier log de synchronisation
let lastSyncLog = null

// Fonction pour ajouter un log (remplace le pr√©c√©dent)
function addSyncLog(message, type = 'info') {
  const log = {
    timestamp: new Date().toISOString(),
    message: message,
    type: type
  }
  
  // Remplacer le log pr√©c√©dent au lieu d'accumuler
  lastSyncLog = log
  
  console.log(`[${type.toUpperCase()}] ${message}`)
}

// GET /api/sync/logs - R√©cup√©rer le dernier log de synchronisation
app.get('/api/sync/logs', (req, res) => {
  res.json({
    success: true,
    log: lastSyncLog,
    hasLog: lastSyncLog !== null
  })
})

// POST /api/sync/logs/clear - Vider le log
app.post('/api/sync/logs/clear', (req, res) => {
  lastSyncLog = null
  res.json({
    success: true,
    message: 'Log vid√© avec succ√®s'
  })
})

// GET /api/test/connection - Test de connexion WordPress
app.get('/api/test/connection', async (req, res) => {
  try {
    if (!WOOCOMMERCE_CONSUMER_KEY || !WOOCOMMERCE_CONSUMER_SECRET) {
      return res.status(500).json({ 
        success: false, 
        error: 'Configuration WooCommerce manquante' 
      })
    }
    
    const authParams = `consumer_key=${WOOCOMMERCE_CONSUMER_KEY}&consumer_secret=${WOOCOMMERCE_CONSUMER_SECRET}`
    const url = `${WOOCOMMERCE_URL}/wp-json/wc/v3/products?${authParams}&per_page=1&_fields=id`
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' },
      signal: AbortSignal.timeout(5000) // Timeout 5 secondes
    })
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }
    
    res.json({ 
      success: true, 
      data: { message: 'Connexion WordPress √©tablie' } 
    })
  } catch (error) {
    console.error('Erreur test WordPress:', error)
    res.status(500).json({ 
      success: false, 
      error: error.message 
    })
  }
})

// GET /api/test/sync - Test de connexion base de donn√©es
app.get('/api/test/sync', async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ 
        success: false, 
        error: 'Base de donn√©es non connect√©e' 
      })
    }
    
    // Test simple de connexion en comptant les documents
    const ordersCollection = db.collection('orders_sync')
    const count = await ordersCollection.countDocuments()
    
    res.json({ 
      success: true, 
      data: { 
        message: 'Connexion base de donn√©es √©tablie',
        ordersCount: count 
      } 
    })
  } catch (error) {
    console.error('Erreur test base de donn√©es:', error)
    res.status(500).json({ 
      success: false, 
      error: error.message 
    })
  }
})

// GET /api/debug/status - Route de debug pour v√©rifier l'√©tat de la base
app.get('/api/debug/status', async (req, res) => {
  try {
    const ordersCollection = db.collection('orders_sync')
    const itemsCollection = db.collection('order_items')
    const statusCollection = db.collection('production_status')
    
    const totalOrders = await ordersCollection.countDocuments()
    const totalItems = await itemsCollection.countDocuments()
    const totalStatuses = await statusCollection.countDocuments()
    
    const statusesByType = await statusCollection.aggregate([
      {
        $group: {
          _id: '$production_type',
          count: { $sum: 1 }
        }
      }
    ]).toArray()
    
    const itemsWithoutStatus = await itemsCollection.aggregate([
      {
        $lookup: {
          from: 'production_status',
          localField: 'line_item_id',
          foreignField: 'line_item_id',
          as: 'status'
        }
      },
      {
        $match: {
          status: { $size: 0 }
        }
      }
    ]).toArray()
    
    res.json({
      success: true,
      debug: {
        totalOrders,
        totalItems,
        totalStatuses,
        statusesByType,
        itemsWithoutStatus: itemsWithoutStatus.length,
        sampleItems: itemsWithoutStatus.slice(0, 3).map(item => ({
          id: item.line_item_id,
          name: item.product_name,
          order_id: item.order_id
        }))
      }
    })
  } catch (error) {
    console.error('Erreur debug:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// D√©marrage du serveur
async function startServer() {
  await connectToMongo()
  
  app.listen(PORT, () => {
    console.log(`üöÄ Serveur MongoDB API d√©marr√© sur le port ${PORT}`)
    console.log(`üìä Endpoints disponibles:`)
    console.log(`   POST /api/sync/orders - Synchroniser les commandes`)
    console.log(`   GET  /api/orders - R√©cup√©rer toutes les commandes`)
    console.log(`   GET  /api/orders/search/:orderNumber - Rechercher une commande par num√©ro`)
    console.log(`   GET  /api/orders/production/:type - Commandes par type de production`)
    console.log(`   POST /api/production/dispatch - Dispatcher vers production`)
    console.log(`   PUT  /api/production/redispatch - Redispatch vers un autre type`)
    console.log(`   PUT  /api/production/status - Mettre √† jour le statut`)
    console.log(`   GET  /api/production-status - Statuts de production`)
    console.log(`   GET  /api/production-status/stats - Statistiques de production`)
    console.log(`   POST /api/production-status - Mettre √† jour statut`)
    console.log(`   GET  /api/woocommerce/products/:productId/permalink - Permalink d'un produit`)
    console.log(`   POST /api/woocommerce/products/permalink/batch - Permalinks en lot`)
    console.log(`   GET  /api/sync/logs - Logs de synchronisation`)
    console.log(`   POST /api/sync/logs/clear - Vider les logs`)
    console.log(`   GET  /api/test/connection - Test connexion WordPress`)
    console.log(`   GET  /api/test/sync - Test connexion base de donn√©es`)
    console.log(`   GET  /api/debug/status - Debug de l'√©tat de la base`)
    console.log(`   GET  /api/tricoteuses - R√©cup√©rer toutes les tricoteuses`)
    console.log(`   POST /api/tricoteuses - Cr√©er une nouvelle tricoteuse`)
    console.log(`   PUT  /api/tricoteuses/:id - Modifier une tricoteuse`)
    console.log(`   DELETE /api/tricoteuses/:id - Supprimer une tricoteuse`)
  })
}

startServer().catch(console.error)
