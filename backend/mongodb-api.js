require('dotenv').config()
const express = require('express')
const { MongoClient, ObjectId } = require('mongodb')
const cors = require('cors')

const app = express()
const PORT = process.env.PORT || 3001

// Middleware
app.use(cors())
app.use(express.json())

// Configuration MongoDB
const mongoUrl = process.env.MONGO_URI || 'mongodb://localhost:27017'
const dbName = 'maisoncleo'

// Configuration WooCommerce (utiliser les variables existantes)
const WOOCOMMERCE_URL = process.env.VITE_WORDPRESS_URL || 'https://maisoncleo.com'
const WOOCOMMERCE_CONSUMER_KEY = process.env.VITE_WORDPRESS_CONSUMER_KEY
const WOOCOMMERCE_CONSUMER_SECRET = process.env.VITE_WORDPRESS_CONSUMER_SECRET

console.log('üîç URL MongoDB configur√©e:', mongoUrl)
console.log('üîç Variables d\'environnement:', {
  MONGO_URI: process.env.MONGO_URI ? '‚úÖ D√©finie' : '‚ùå Manquante',
  WOOCOMMERCE_URL: WOOCOMMERCE_URL ? '‚úÖ D√©finie' : '‚ùå Manquante',
  WOOCOMMERCE_CONSUMER_KEY: WOOCOMMERCE_CONSUMER_KEY ? '‚úÖ D√©finie' : '‚ùå Manquante',
  WOOCOMMERCE_CONSUMER_SECRET: WOOCOMMERCE_CONSUMER_SECRET ? '‚úÖ D√©finie' : '‚ùå Manquante',
  PORT: process.env.PORT || '3001 (d√©faut)'
})

let db

// Connexion √† MongoDB
async function connectToMongo() {
  try {
    const client = new MongoClient(mongoUrl)
    await client.connect()
    db = client.db(dbName)
    
    // Cr√©er les collections et index n√©cessaires
    await createCollectionsAndIndexes()
    
    console.log('‚úÖ Connect√© √† MongoDB Atlas')
  } catch (error) {
    console.error('‚ùå Erreur de connexion MongoDB:', error)
  }
}

// Cr√©er les collections et index
async function createCollectionsAndIndexes() {
  try {
    // Collection des commandes synchronis√©es
    const ordersCollection = db.collection('orders_sync')
    await ordersCollection.createIndex({ order_id: 1 }, { unique: true })
    await ordersCollection.createIndex({ order_date: -1 })
    
    // Collection des articles de commande
    const itemsCollection = db.collection('order_items')
    await itemsCollection.createIndex({ order_id: 1 })
    await itemsCollection.createIndex({ order_id: 1, line_item_id: 1 }, { unique: true })
    
    // Collection des statuts de production
    const statusCollection = db.collection('production_status')
    await statusCollection.createIndex({ order_id: 1, line_item_id: 1 }, { unique: true })
    await statusCollection.createIndex({ production_type: 1 })
    await statusCollection.createIndex({ status: 1 })
    
    console.log('‚úÖ Collections et index cr√©√©s')
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation collections:', error)
  }
}

// Routes API

// GET /api/woocommerce/products/:productId/permalink - R√©cup√©rer le permalink d'un produit
app.get('/api/woocommerce/products/:productId/permalink', async (req, res) => {
  try {
    const { productId } = req.params
    
    if (!WOOCOMMERCE_CONSUMER_KEY || !WOOCOMMERCE_CONSUMER_SECRET) {
      return res.status(500).json({ 
        error: 'Configuration WooCommerce manquante',
        message: 'Veuillez configurer WOOCOMMERCE_CONSUMER_KEY et WOOCOMMERCE_CONSUMER_SECRET'
      })
    }
    
    const authParams = `consumer_key=${WOOCOMMERCE_CONSUMER_KEY}&consumer_secret=${WOOCOMMERCE_CONSUMER_SECRET}`
    const url = `${WOOCOMMERCE_URL}/wp-json/wc/v3/products/${productId}?${authParams}&_fields=id,permalink`
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
      },
      // Timeout de 5 secondes
      signal: AbortSignal.timeout(5000)
    })
    
    if (!response.ok) {
      if (response.status === 404) {
        return res.status(404).json({ error: 'Produit non trouv√©' })
      } else if (response.status >= 500) {
        return res.status(502).json({ error: 'Erreur serveur WooCommerce' })
      } else {
        return res.status(response.status).json({ error: `Erreur HTTP: ${response.status}` })
      }
    }
    
    const product = await response.json()
    const permalink = product?.permalink || null
    
    if (!permalink) {
      return res.status(404).json({ error: 'Permalink non trouv√© pour ce produit' })
    }
    
    res.json({ 
      success: true,
      product_id: parseInt(productId),
      permalink: permalink
    })
    
  } catch (error) {
    if (error.name === 'TimeoutError') {
      return res.status(408).json({ error: 'Timeout lors de la r√©cup√©ration du permalink' })
    }
    
    console.error('Erreur GET /woocommerce/products/:productId/permalink:', error)
    res.status(500).json({ error: 'Erreur serveur interne' })
  }
})

// GET /api/woocommerce/products/permalink/batch - R√©cup√©rer les permalinks de plusieurs produits
app.post('/api/woocommerce/products/permalink/batch', async (req, res) => {
  try {
    const { productIds } = req.body
    
    if (!Array.isArray(productIds) || productIds.length === 0) {
      return res.status(400).json({ error: 'Liste de productIds invalide' })
    }
    
    if (!WOOCOMMERCE_CONSUMER_KEY || !WOOCOMMERCE_CONSUMER_SECRET) {
      return res.status(500).json({ 
        error: 'Configuration WooCommerce manquante',
        message: 'Veuillez configurer WOOCOMMERCE_CONSUMER_KEY et WOOCOMMERCE_CONSUMER_SECRET'
      })
    }
    
    const authParams = `consumer_key=${WOOCOMMERCE_CONSUMER_KEY}&consumer_secret=${WOOCOMMERCE_CONSUMER_SECRET}`
    const results = []
    const errors = []
    
    // Traiter les produits en parall√®le avec un d√©lai pour √©viter la surcharge
    for (let i = 0; i < productIds.length; i++) {
      const productId = productIds[i]
      
      try {
        // D√©lai entre les requ√™tes pour √©viter la surcharge
        if (i > 0) {
          await new Promise(resolve => setTimeout(resolve, 100))
        }
        
        const url = `${WOOCOMMERCE_URL}/wp-json/wc/v3/products/${productId}?${authParams}&_fields=id,permalink`
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
          },
          signal: AbortSignal.timeout(3000)
        })
        
        if (response.ok) {
          const product = await response.json()
          if (product?.permalink) {
            results.push({
              product_id: parseInt(productId),
              permalink: product.permalink
            })
          }
        } else {
          errors.push({
            product_id: parseInt(productId),
            error: `HTTP ${response.status}`,
            status: response.status
          })
        }
      } catch (error) {
        errors.push({
          product_id: parseInt(productId),
          error: error.message,
          type: error.name
        })
      }
    }
    
    res.json({ 
      success: true,
      results: results,
      errors: errors,
      total_processed: productIds.length,
      total_success: results.length,
      total_errors: errors.length
    })
    
  } catch (error) {
    console.error('Erreur POST /woocommerce/products/permalink/batch:', error)
    res.status(500).json({ error: 'Erreur serveur interne' })
  }
})

// POST /api/sync/orders - Synchroniser les commandes WooCommerce
app.post('/api/sync/orders', async (req, res) => {
  try {
    addSyncLog('üîÑ D√©but de la synchronisation des commandes', 'info')
    
    // R√©cup√©rer les commandes depuis WooCommerce
    let woocommerceOrders = []
    
    if (WOOCOMMERCE_CONSUMER_KEY && WOOCOMMERCE_CONSUMER_SECRET) {
      try {
        const authParams = `consumer_key=${WOOCOMMERCE_CONSUMER_KEY}&consumer_secret=${WOOCOMMERCE_CONSUMER_SECRET}`
        const url = `${WOOCOMMERCE_URL}/wp-json/wc/v3/orders?${authParams}&per_page=50&status=processing,completed&orderby=date&order=desc`
        
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
          },
          signal: AbortSignal.timeout(10000)
        })
        
        if (response.ok) {
          woocommerceOrders = await response.json()
        } else {
          addSyncLog(`‚ö†Ô∏è Erreur HTTP ${response.status} lors de la r√©cup√©ration des commandes`, 'warning')
        }
      } catch (error) {
        addSyncLog(`‚ö†Ô∏è Erreur lors de la r√©cup√©ration des commandes WooCommerce: ${error.message}`, 'error')
      }
    } else {
      addSyncLog('‚ö†Ô∏è Cl√©s WooCommerce non configur√©es, synchronisation impossible', 'error')
      return res.status(500).json({ 
        error: 'Configuration WooCommerce manquante',
        message: 'Veuillez configurer les cl√©s API WooCommerce'
      })
    }
    
    if (woocommerceOrders.length === 0) {
      addSyncLog('‚ÑπÔ∏è Aucune commande √† synchroniser', 'info')
      return res.json({
        success: true,
        message: 'Aucune nouvelle commande',
        results: {
          ordersCreated: 0,
          ordersUpdated: 0,
          itemsCreated: 0,
          itemsUpdated: 0
        }
      })
    }
    
    // Synchroniser les commandes
    addSyncLog('üîÑ D√©but de la synchronisation avec la base de donn√©es...', 'info')
    const syncResults = await syncOrdersToDatabase(woocommerceOrders)
    
    // Afficher le message appropri√© selon le r√©sultat
    if (syncResults.ordersCreated === 0 && syncResults.itemsCreated === 0) {
      addSyncLog('‚ÑπÔ∏è Aucune nouvelle commande √† traiter', 'info')
    } else {
      addSyncLog('‚úÖ Synchronisation termin√©e avec succ√®s', 'success')
    }
    
    res.json({
      success: true,
      message: 'Synchronisation r√©ussie',
      results: syncResults
    })
    
  } catch (error) {
    addSyncLog(`‚ùå Erreur lors de la synchronisation: ${error.message}`, 'error')
    res.status(500).json({ 
      error: 'Erreur lors de la synchronisation',
      message: error.message 
    })
  }
})

// GET /api/orders - R√©cup√©rer toutes les commandes avec articles et statuts
app.get('/api/orders', async (req, res) => {
  try {
    const ordersCollection = db.collection('orders_sync')
    const itemsCollection = db.collection('order_items')
    const statusCollection = db.collection('production_status')
    
    // R√©cup√©rer toutes les commandes
    const orders = await ordersCollection.find({}).sort({ order_date: -1 }).toArray()
    
    // Pour chaque commande, r√©cup√©rer les articles et statuts
    const ordersWithDetails = await Promise.all(orders.map(async (order) => {
      const items = await itemsCollection.find({ order_id: order.order_id }).toArray()
      
      // Ajouter les statuts de production √† chaque article
      const itemsWithStatus = await Promise.all(items.map(async (item) => {
        const status = await statusCollection.findOne({
          order_id: order.order_id,
          line_item_id: item.line_item_id
        })
        
        return {
          ...item,
          production_status: status || {
            status: 'a_faire',
            production_type: null,
            assigned_to: null
          }
        }
      }))
      
      return {
        ...order,
        items: itemsWithStatus
      }
    }))
    
    res.json({ orders: ordersWithDetails })
  } catch (error) {
    console.error('Erreur GET /orders:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// GET /api/orders/production/:type - R√©cup√©rer les commandes par type de production
app.get('/api/orders/production/:type', async (req, res) => {
  try {
    const { type } = req.params // 'couture' ou 'maille'
    const statusCollection = db.collection('production_status')
    const itemsCollection = db.collection('order_items')
    
    // R√©cup√©rer les articles assign√©s √† ce type de production
    const assignedItems = await statusCollection.find({
      production_type: type
    }).toArray()
    
    console.log(`üìä Articles trouv√©s pour ${type}:`, assignedItems.length)
    
    // Si aucun article n'est dispatch√©, essayer de dispatcher automatiquement
    if (assignedItems.length === 0) {
      console.log(`üîÑ Aucun article dispatch√© pour ${type}, tentative de dispatch automatique...`)
      
      // R√©cup√©rer tous les articles
      const allItems = await itemsCollection.find({}).toArray()
      console.log(`üìã Total d'articles en base:`, allItems.length)
      
      // Dispatcher automatiquement les articles non dispatch√©s
      for (const item of allItems) {
        const existingStatus = await statusCollection.findOne({
          order_id: item.order_id,
          line_item_id: item.line_item_id
        })
        
        if (!existingStatus) {
          const productionType = determineProductionType(item.product_name)
          console.log(`üìã Dispatch automatique: ${item.product_name} -> ${productionType}`)
          
          if (productionType === type) {
            const productionStatus = {
              order_id: parseInt(item.order_id),
              line_item_id: parseInt(item.line_item_id),
              status: 'a_faire',
              production_type: productionType,
              assigned_to: null,
              created_at: new Date(),
              updated_at: new Date()
            }
            
            await statusCollection.insertOne(productionStatus)
            assignedItems.push(productionStatus)
          }
        }
      }
      
      console.log(`‚úÖ Articles dispatch√©s pour ${type}:`, assignedItems.length)
    }
    
    // R√©cup√©rer les d√©tails des commandes et articles
    const ordersWithDetails = await Promise.all(assignedItems.map(async (status) => {
      const order = await db.collection('orders_sync').findOne({ order_id: status.order_id })
      const item = await db.collection('order_items').findOne({
        order_id: status.order_id,
        line_item_id: status.line_item_id
      })
      
      // Retourner la structure attendue par le frontend
      return {
        ...order,
        items: [{
          ...item,
          production_status: status
        }]
      }
    }))
    
    res.json({ orders: ordersWithDetails })
  } catch (error) {
    console.error('Erreur GET /orders/production/:type:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// POST /api/production/dispatch - Dispatcher un article vers la production
app.post('/api/production/dispatch', async (req, res) => {
  try {
    const { order_id, line_item_id, production_type, assigned_to } = req.body
    
    if (!order_id || !line_item_id || !production_type) {
      return res.status(400).json({ error: 'Param√®tres manquants' })
    }
    
    const statusCollection = db.collection('production_status')
    
    const result = await statusCollection.updateOne(
      {
        order_id: parseInt(order_id),
        line_item_id: parseInt(line_item_id)
      },
      {
        $set: {
          order_id: parseInt(order_id),
          line_item_id: parseInt(line_item_id),
          status: 'en_cours',
          production_type,
          assigned_to: assigned_to || null,
          updated_at: new Date()
        }
      },
      { upsert: true }
    )
    
    res.json({ 
      success: true, 
      message: 'Article dispatch√© vers la production',
      result 
    })
  } catch (error) {
    console.error('Erreur POST /production/dispatch:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// PUT /api/production/redispatch - Redispatch un article vers un autre type de production
app.put('/api/production/redispatch', async (req, res) => {
  try {
    const { order_id, line_item_id, new_production_type } = req.body
    
    if (!order_id || !line_item_id || !new_production_type) {
      return res.status(400).json({ error: 'Param√®tres manquants' })
    }
    
    const statusCollection = db.collection('production_status')
    
    // V√©rifier que l'article existe
    const existingStatus = await statusCollection.findOne({
      order_id: parseInt(order_id),
      line_item_id: parseInt(line_item_id)
    })
    
    if (!existingStatus) {
      return res.status(404).json({ error: 'Article non trouv√©' })
    }
    
    // Mettre √† jour le type de production
    const result = await statusCollection.updateOne(
      {
        order_id: parseInt(order_id),
        line_item_id: parseInt(line_item_id)
      },
      {
        $set: {
          production_type: new_production_type,
          updated_at: new Date()
        }
      }
    )
    
    res.json({ 
      success: true, 
      message: `Article redispatch√© vers ${new_production_type}`,
      result 
    })
  } catch (error) {
    console.error('Erreur PUT /production/redispatch:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// PUT /api/production/status - Mettre √† jour le statut de production
app.put('/api/production/status', async (req, res) => {
  try {
    const { order_id, line_item_id, status, notes } = req.body
    
    if (!order_id || !line_item_id || !status) {
      return res.status(400).json({ error: 'Param√®tres manquants' })
    }
    
    const statusCollection = db.collection('production_status')
    
    const result = await statusCollection.updateOne(
      {
        order_id: parseInt(order_id),
        line_item_id: parseInt(line_item_id)
      },
      {
        $set: {
          status,
          notes: notes || null,
          updated_at: new Date()
        }
      }
    )
    
    if (result.matchedCount === 0) {
      return res.status(404).json({ error: 'Article non trouv√©' })
    }
    
    res.json({ 
      success: true, 
      message: 'Statut mis √† jour',
      result 
    })
  } catch (error) {
    console.error('Erreur PUT /production/status:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// Fonctions utilitaires

// Fonction pour synchroniser toutes les commandes vers la base de donn√©es
async function syncOrdersToDatabase(woocommerceOrders) {
  const syncResults = {
    ordersCreated: 0,
    ordersUpdated: 0,
    itemsCreated: 0,
    itemsUpdated: 0,
    errors: []
  }
  
  // R√©cup√©rer les IDs des commandes d√©j√† existantes
  const ordersCollection = db.collection('orders_sync')
  const existingOrderIds = await ordersCollection.distinct('order_id')
  
  addSyncLog(`üìä ${existingOrderIds.length} commandes d√©j√† existantes en BDD`, 'info')
  
  // Filtrer pour ne traiter que les nouvelles commandes
  const newOrders = woocommerceOrders.filter(order => !existingOrderIds.includes(order.id))
  const existingOrders = woocommerceOrders.filter(order => existingOrderIds.includes(order.id))
  
  if (newOrders.length === 0) {
    addSyncLog('‚ÑπÔ∏è Aucune nouvelle commande √† traiter', 'info')
    return syncResults
  }
  
  addSyncLog(`üîÑ Traitement de ${newOrders.length} nouvelles commandes...`, 'info')
  
  // Traiter seulement les nouvelles commandes
  for (const order of newOrders) {
    try {
      addSyncLog(`‚ú® Cr√©ation de la nouvelle commande #${order.number}`, 'success')
      const orderResult = await syncOrderToDatabase(order)
      if (orderResult.created) {
        syncResults.ordersCreated++
      }
      
      // Nouveaux articles - cr√©ation compl√®te
      for (const item of order.line_items || []) {
        const itemResult = await syncOrderItem(order.id, item)
        if (itemResult.created) {
          syncResults.itemsCreated++
          
          // Dispatcher automatiquement l'article vers la production
          await dispatchItemToProduction(order.id, item.id, item.name)
        }
      }
    } catch (error) {
      addSyncLog(`‚ùå Erreur sur la commande #${order.number}: ${error.message}`, 'error')
      syncResults.errors.push({
        orderId: order.id,
        error: error.message
      })
    }
  }
  
  addSyncLog(`üìä R√©sultats: ${syncResults.ordersCreated} cr√©√©es, ${syncResults.itemsCreated} articles cr√©√©s`, 'info')
  
  // Dispatcher automatiquement les articles existants qui n'ont pas de statut de production
  if (syncResults.itemsCreated > 0) {
    addSyncLog('üîÑ Dispatch automatique des articles vers la production...', 'info')
    await dispatchExistingItemsToProduction()
  }
  
  return syncResults
}

// Fonction pour dispatcher automatiquement un article vers la production
async function dispatchItemToProduction(orderId, lineItemId, productName) {
  try {
    const statusCollection = db.collection('production_status')
    
    // D√©terminer le type de production bas√© sur le nom du produit
    const productionType = determineProductionType(productName)
    
    // Cr√©er le statut de production avec "a_faire"
    const productionStatus = {
      order_id: parseInt(orderId),
      line_item_id: parseInt(lineItemId),
      status: 'a_faire',
      production_type: productionType,
      assigned_to: null,
      created_at: new Date(),
      updated_at: new Date()
    }
    
    await statusCollection.insertOne(productionStatus)
    
    addSyncLog(`üìã Article dispatch√© vers ${productionType}`, 'info')
  } catch (error) {
    console.warn(`Erreur lors du dispatch automatique vers la production: ${error.message}`)
  }
}

// Fonction pour d√©terminer le type de production d'un produit
function determineProductionType(productName) {
  const name = productName.toLowerCase()
  
  // Seulement les mots sp√©cifiquement li√©s au tricot/maille
  const mailleKeywords = [
    'tricot√©e', 'tricot√©', 'knitted'
  ]
  
  // Si le produit contient un de ces mots ‚Üí maille, sinon ‚Üí couture
  if (mailleKeywords.some(keyword => name.includes(keyword))) {
    return 'maille'
  }
  
  return 'couture'
}

// Fonction pour dispatcher automatiquement les articles existants vers la production
async function dispatchExistingItemsToProduction() {
  try {
    const itemsCollection = db.collection('order_items')
    const statusCollection = db.collection('production_status')
    
    // R√©cup√©rer tous les articles qui n'ont pas encore de statut de production
    const itemsWithoutStatus = await itemsCollection.aggregate([
      {
        $lookup: {
          from: 'production_status',
          localField: 'line_item_id',
          foreignField: 'line_item_id',
          as: 'status'
        }
      },
      {
        $match: {
          status: { $size: 0 }
        }
      }
    ]).toArray()
    
    if (itemsWithoutStatus.length > 0) {
      addSyncLog(`üìã Dispatch de ${itemsWithoutStatus.length} articles existants...`, 'info')
      
      for (const item of itemsWithoutStatus) {
        const productionType = determineProductionType(item.product_name)
        
        const productionStatus = {
          order_id: parseInt(item.order_id),
          line_item_id: parseInt(item.line_item_id),
          status: 'a_faire',
          production_type: productionType,
          assigned_to: null,
          created_at: new Date(),
          updated_at: new Date()
        }
        
        await statusCollection.insertOne(productionStatus)
      }
      
      addSyncLog(`‚úÖ ${itemsWithoutStatus.length} articles dispatch√©s avec succ√®s`, 'success')
    }
  } catch (error) {
    console.warn(`Erreur lors du dispatch des articles existants: ${error.message}`)
  }
}

// Fonction pour synchroniser une commande vers la base de donn√©es
async function syncOrderToDatabase(order) {
  const ordersCollection = db.collection('orders_sync')
  
  // Cr√©er la nouvelle commande
  const orderData = {
    order_id: order.id,
    order_number: order.number,
    order_date: new Date(order.date_created),
    customer_name: order.billing?.first_name + ' ' + order.billing?.last_name,
    customer_email: order.billing?.email,
    customer_phone: order.billing?.phone,
    customer_address: `${order.billing?.address_1}, ${order.billing?.postcode} ${order.billing?.city}`,
    customer_note: order.customer_note || '',
    status: order.status,
    total: parseFloat(order.total) || 0,
    created_at: new Date(),
    updated_at: new Date()
  }
  
  const result = await ordersCollection.insertOne(orderData)
  
  return {
    created: result.insertedCount > 0,
    updated: false
  }
}

async function syncOrderItem(orderId, item) {
  const itemsCollection = db.collection('order_items')
  
  // R√©cup√©rer le permalink depuis WooCommerce via notre API
  let permalink = null
  try {
    if (WOOCOMMERCE_CONSUMER_KEY && WOOCOMMERCE_CONSUMER_SECRET) {
      const authParams = `consumer_key=${WOOCOMMERCE_CONSUMER_KEY}&consumer_secret=${WOOCOMMERCE_CONSUMER_SECRET}`
      const url = `${WOOCOMMERCE_URL}/wp-json/wc/v3/products/${item.product_id}?${authParams}&_fields=id,permalink`
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
        },
        signal: AbortSignal.timeout(3000)
      })
      
      if (response.ok) {
        const product = await response.json()
        permalink = product?.permalink || null
      }
    }
  } catch (error) {
    console.warn(`Erreur lors de la r√©cup√©ration du permalink pour le produit ${item.product_id}:`, error.message)
  }
  
  // Cr√©er le nouvel article
  const itemData = {
    order_id: orderId,
    line_item_id: item.id,
    product_name: item.name,
    product_id: item.product_id,
    variation_id: item.variation_id,
    quantity: item.quantity,
    price: parseFloat(item.price) || 0,
    permalink: permalink, // Stocker le vrai permalink
    meta_data: item.meta_data || [],
    created_at: new Date(),
    updated_at: new Date()
  }
  
  const result = await itemsCollection.insertOne(itemData)
  
  return {
    created: result.insertedCount > 0,
    updated: false
  }
}

// Routes existantes pour la compatibilit√©
app.get('/api/production-status', async (req, res) => {
  try {
    const collection = db.collection('production_status')
    const statuses = await collection.find({}).toArray()
    res.json({ statuses })
  } catch (error) {
    console.error('Erreur GET /production-status:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

app.post('/api/production-status', async (req, res) => {
  try {
    const { order_id, line_item_id, status, assigned_to } = req.body
    const collection = db.collection('production_status')
    
    const result = await collection.updateOne(
      {
        order_id: parseInt(order_id),
        line_item_id: parseInt(line_item_id)
      },
      {
        $set: {
          order_id: parseInt(order_id),
          line_item_id: parseInt(line_item_id),
          status,
          assigned_to,
          updated_at: new Date()
        }
      },
      { upsert: true }
    )
    
    res.json({ 
      success: true, 
      message: 'Statut mis √† jour',
      result 
    })
  } catch (error) {
    console.error('Erreur POST /production-status:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// Variable globale pour stocker le dernier log de synchronisation
let lastSyncLog = null

// Fonction pour ajouter un log (remplace le pr√©c√©dent)
function addSyncLog(message, type = 'info') {
  const log = {
    timestamp: new Date().toISOString(),
    message: message,
    type: type
  }
  
  // Remplacer le log pr√©c√©dent au lieu d'accumuler
  lastSyncLog = log
  
  console.log(`[${type.toUpperCase()}] ${message}`)
}

// GET /api/sync/logs - R√©cup√©rer le dernier log de synchronisation
app.get('/api/sync/logs', (req, res) => {
  res.json({
    success: true,
    log: lastSyncLog,
    hasLog: lastSyncLog !== null
  })
})

// POST /api/sync/logs/clear - Vider le log
app.post('/api/sync/logs/clear', (req, res) => {
  lastSyncLog = null
  res.json({
    success: true,
    message: 'Log vid√© avec succ√®s'
  })
})

// GET /api/debug/status - Route de debug pour v√©rifier l'√©tat de la base
app.get('/api/debug/status', async (req, res) => {
  try {
    const ordersCollection = db.collection('orders_sync')
    const itemsCollection = db.collection('order_items')
    const statusCollection = db.collection('production_status')
    
    const totalOrders = await ordersCollection.countDocuments()
    const totalItems = await itemsCollection.countDocuments()
    const totalStatuses = await statusCollection.countDocuments()
    
    const statusesByType = await statusCollection.aggregate([
      {
        $group: {
          _id: '$production_type',
          count: { $sum: 1 }
        }
      }
    ]).toArray()
    
    const itemsWithoutStatus = await itemsCollection.aggregate([
      {
        $lookup: {
          from: 'production_status',
          localField: 'line_item_id',
          foreignField: 'line_item_id',
          as: 'status'
        }
      },
      {
        $match: {
          status: { $size: 0 }
        }
      }
    ]).toArray()
    
    res.json({
      success: true,
      debug: {
        totalOrders,
        totalItems,
        totalStatuses,
        statusesByType,
        itemsWithoutStatus: itemsWithoutStatus.length,
        sampleItems: itemsWithoutStatus.slice(0, 3).map(item => ({
          id: item.line_item_id,
          name: item.product_name,
          order_id: item.order_id
        }))
      }
    })
  } catch (error) {
    console.error('Erreur debug:', error)
    res.status(500).json({ error: 'Erreur serveur' })
  }
})

// D√©marrage du serveur
async function startServer() {
  await connectToMongo()
  
  app.listen(PORT, () => {
    console.log(`üöÄ Serveur MongoDB API d√©marr√© sur le port ${PORT}`)
    console.log(`üìä Endpoints disponibles:`)
    console.log(`   POST /api/sync/orders - Synchroniser les commandes`)
    console.log(`   GET  /api/orders - R√©cup√©rer toutes les commandes`)
    console.log(`   GET  /api/orders/production/:type - Commandes par type de production`)
    console.log(`   POST /api/production/dispatch - Dispatcher vers production`)
    console.log(`   PUT  /api/production/redispatch - Redispatch vers un autre type`)
    console.log(`   PUT  /api/production/status - Mettre √† jour le statut`)
    console.log(`   GET  /api/production-status - Statuts de production`)
    console.log(`   POST /api/production-status - Mettre √† jour statut`)
    console.log(`   GET  /api/woocommerce/products/:productId/permalink - Permalink d'un produit`)
    console.log(`   POST /api/woocommerce/products/permalink/batch - Permalinks en lot`)
    console.log(`   GET  /api/sync/logs - Logs de synchronisation`)
    console.log(`   POST /api/sync/logs/clear - Vider les logs`)
    console.log(`   GET  /api/debug/status - Debug de l'√©tat de la base`)
  })
}

startServer().catch(console.error)
