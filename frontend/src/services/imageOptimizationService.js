/**
 * Service d'optimisation des images ultra-rapide
 * Gestion intelligente du cache et pr√©chargement pour Render
 */

import { useState, useEffect } from 'react'

// Cache global ultra-simple et instantan√©
const imageCache = new Map()
const preloadQueue = new Set()
const loadingPromises = new Map()
const httpCache = new Map() // Cache HTTP persistant

// Cache persistant avec localStorage et sessionStorage
const PERSISTENT_CACHE_KEY = 'mc-image-cache-v1'
const SESSION_CACHE_KEY = 'mc-session-cache-v1'

// Charger le cache persistant au d√©marrage
const loadPersistentCache = () => {
  try {
    const stored = localStorage.getItem(PERSISTENT_CACHE_KEY)
    if (stored) {
      const data = JSON.parse(stored)
      data.forEach(([key, value]) => httpCache.set(key, value))
      console.log(`üì¶ Cache persistant charg√©: ${httpCache.size} images`)
    }
  } catch (error) {
    console.warn('Erreur chargement cache persistant:', error)
  }
}

// Sauvegarder le cache persistant
const savePersistentCache = () => {
  try {
    const data = Array.from(httpCache.entries())
    localStorage.setItem(PERSISTENT_CACHE_KEY, JSON.stringify(data))
    console.log(`üíæ Cache persistant sauvegard√©: ${data.length} images`)
  } catch (error) {
    console.warn('Erreur sauvegarde cache persistant:', error)
  }
}

// Charger le cache de session
const loadSessionCache = () => {
  try {
    const stored = sessionStorage.getItem(SESSION_CACHE_KEY)
    if (stored) {
      const data = JSON.parse(stored)
      data.forEach(([key, value]) => imageCache.set(key, value))
      console.log(`üì¶ Cache session charg√©: ${imageCache.size} images`)
    }
  } catch (error) {
    console.warn('Erreur chargement cache session:', error)
  }
}

// Sauvegarder le cache de session
const saveSessionCache = () => {
  try {
    const data = Array.from(imageCache.entries())
    sessionStorage.setItem(SESSION_CACHE_KEY, JSON.stringify(data))
    console.log(`üíæ Cache session sauvegard√©: ${data.length} images`)
  } catch (error) {
    console.warn('Erreur sauvegarde cache session:', error)
  }
}

// Initialiser les caches au d√©marrage
loadPersistentCache()
loadSessionCache()

// Nettoyer le cache ancien au d√©marrage
setTimeout(() => {
  ImageOptimizationService.cleanupOldCache()
}, 1000)

// Sauvegarder p√©riodiquement (toutes les 30 secondes)
setInterval(() => {
  if (imageCache.size > 0) saveSessionCache()
  if (httpCache.size > 0) savePersistentCache()
}, 30000)

// Configuration optimis√©e pour Render (chargement progressif)
const RENDER_CONFIG = {
  maxConcurrentPreloads: 3, // R√©duit pour √©viter la surcharge
  preloadTimeout: 5000, // Timeout r√©duit
  cacheSize: 50, // Cache r√©duit
  priorityThreshold: 0.8,
  batchSize: 10 // Taille de lot r√©duite
}

// D√©tecter les appareils lents et ajuster la config
const isSlowDevice = () => {
  if (typeof navigator === 'undefined') return false
  return navigator.deviceMemory && navigator.deviceMemory < 2 // Seuil abaiss√© pour Render
}

// Configuration adaptative (optimis√©e pour Render)
const getAdaptiveConfig = () => {
  if (isSlowDevice()) {
    return {
      maxConcurrentPreloads: 2, // Tr√®s r√©duit pour appareils lents
      preloadTimeout: 3000, // Timeout court
      cacheSize: 25, // Cache petit
      priorityThreshold: 0.9,
      batchSize: 5 // Tr√®s petit lot
    }
  }
  return RENDER_CONFIG
}

/**
 * Service de pr√©chargement intelligent
 */
export const ImageOptimizationService = {
  /**
   * Pr√©charger une image avec cache HTTP optimis√© (INSTANTAN√â)
   */
  preloadImage: async (url, priority = false) => {
    // 1. V√©rifier le cache m√©moire (instantan√©)
    if (imageCache.has(url)) {
      console.log(`‚ö° Cache m√©moire: ${url.split('/').pop()}`)
      return Promise.resolve(imageCache.get(url))
    }

    // 2. V√©rifier le cache HTTP persistant
    if (httpCache.has(url)) {
      const cachedUrl = httpCache.get(url)
      imageCache.set(url, cachedUrl)
      console.log(`‚ö° Cache HTTP: ${url.split('/').pop()}`)
      return Promise.resolve(cachedUrl)
    }

    // 3. V√©rifier le sessionStorage (fallback)
    try {
      const sessionData = sessionStorage.getItem(SESSION_CACHE_KEY)
      if (sessionData) {
        const sessionCache = new Map(JSON.parse(sessionData))
        if (sessionCache.has(url)) {
          const cachedUrl = sessionCache.get(url)
          imageCache.set(url, cachedUrl)
          console.log(`‚ö° Cache session: ${url.split('/').pop()}`)
          return Promise.resolve(cachedUrl)
        }
      }
    } catch (error) {
      console.warn('Erreur lecture sessionStorage:', error)
    }

    // 4. V√©rifier le localStorage (fallback final)
    try {
      const persistentData = localStorage.getItem(PERSISTENT_CACHE_KEY)
      if (persistentData) {
        const persistentCache = new Map(JSON.parse(persistentData))
        if (persistentCache.has(url)) {
          const cachedUrl = persistentCache.get(url)
          imageCache.set(url, cachedUrl)
          httpCache.set(url, cachedUrl) // Remettre dans le cache HTTP
          console.log(`‚ö° Cache localStorage: ${url.split('/').pop()}`)
          return Promise.resolve(cachedUrl)
        }
      }
    } catch (error) {
      console.warn('Erreur lecture localStorage:', error)
    }

    // 5. V√©rifier si d√©j√† en cours de chargement
    if (preloadQueue.has(url)) {
      return loadingPromises.get(url) || Promise.resolve()
    }

    preloadQueue.add(url)
    
    const promise = new Promise(async (resolve, reject) => {
      try {
        // 4. Pr√©charger avec une image invisible pour forcer le cache HTTP
      const img = new Image()

        img.onload = () => {
          // 5. Image charg√©e et mise en cache HTTP - stocker dans les deux caches
          imageCache.set(url, url)
          httpCache.set(url, url) // Cache persistant
          preloadQueue.delete(url)
          loadingPromises.delete(url)
          console.log(`‚úÖ Image mise en cache: ${url.split('/').pop()} (total: ${imageCache.size})`)
          resolve(url)
        }

        img.onerror = () => {
          preloadQueue.delete(url)
          loadingPromises.delete(url)
          console.log(`‚ùå Erreur chargement image: ${url.split('/').pop()}`)
          reject(new Error('Failed to preload image'))
        }

        // 6. Forcer le chargement avec cache HTTP et headers optimis√©s
        img.crossOrigin = 'anonymous'
        img.loading = priority ? 'eager' : 'lazy'
        
        // Ajouter un timeout pour d√©tecter les images qui ne se chargent pas
        const timeout = setTimeout(() => {
          console.log(`‚è∞ Timeout image: ${url.split('/').pop()}`)
          preloadQueue.delete(url)
          loadingPromises.delete(url)
          reject(new Error('Image loading timeout'))
        }, 10000) // 10 secondes de timeout
        
        img.onload = () => {
          clearTimeout(timeout)
          // 5. Image charg√©e et mise en cache HTTP - stocker dans les deux caches
          imageCache.set(url, url)
          httpCache.set(url, url) // Cache persistant
          preloadQueue.delete(url)
          loadingPromises.delete(url)
          console.log(`‚úÖ Image mise en cache: ${url.split('/').pop()} (total: ${imageCache.size})`)
          
          // Sauvegarder imm√©diatement les caches
          saveSessionCache()
          savePersistentCache()
          
          resolve(url)
        }
        
        img.onerror = () => {
          clearTimeout(timeout)
          preloadQueue.delete(url)
          loadingPromises.delete(url)
          console.log(`‚ùå Erreur chargement image: ${url.split('/').pop()}`)
          reject(new Error('Failed to preload image'))
        }
        
        img.src = url
        
        // 7. Forcer le cache HTTP avec fetch (optionnel)
        try {
          const response = await fetch(url, {
            method: 'HEAD',
            cache: 'force-cache',
            headers: {
              'Cache-Control': 'max-age=31536000'
            }
          })
          if (response.ok) {
            httpCache.set(url, url)
          }
        } catch (e) {
          // Ignore fetch errors, continue with image loading
        }
        
      } catch (error) {
        preloadQueue.delete(url)
        loadingPromises.delete(url)
        reject(error)
      }
    })

    loadingPromises.set(url, promise)
    return promise
  },

  /**
   * Pr√©charger un lot d'images simultan√©ment (ULTRA-RAPIDE)
   */
  preloadBatch: async (imageUrls, priority = false) => {
    if (!Array.isArray(imageUrls) || imageUrls.length === 0) return []
    
    console.log(`üñºÔ∏è Pr√©chargement en lot: ${imageUrls.length} images`)
    
    // Pr√©charger toutes les images en parall√®le (instantan√© avec cache HTTP)
    const promises = imageUrls.map(url => ImageOptimizationService.preloadImage(url, priority))
    
    try {
      const results = await Promise.allSettled(promises)
      const successful = results
        .filter(result => result.status === 'fulfilled')
        .map(result => result.value)
      
      console.log(`üéâ Pr√©chargement termin√©: ${successful.length}/${imageUrls.length} images`)
      return successful
      } catch (error) {
      console.warn('Erreur pr√©chargement batch:', error)
      return []
    }
  },


  /**
   * Obtenir une image du cache ou la pr√©charger (INSTANTAN√â)
   */
  getImage: async (url, priority = false) => {
    // 1. V√©rifier le cache m√©moire (instantan√©)
    if (imageCache.has(url)) {
      return imageCache.get(url)
    }

    // 2. V√©rifier le cache HTTP persistant
    if (httpCache.has(url)) {
      const cachedUrl = httpCache.get(url)
      imageCache.set(url, cachedUrl)
      return cachedUrl
    }

    // 3. Pr√©charger et retourner l'URL directe
    try {
      return await ImageOptimizationService.preloadImage(url, priority)
    } catch (error) {
      console.warn('Erreur pr√©chargement image:', error)
      return url // Retourner l'URL directe m√™me en cas d'erreur
    }
  },

  /**
   * Nettoyer le cache si n√©cessaire (simple)
   */
  cleanupCache: () => {
    if (imageCache.size > 100) {
      const entries = Array.from(imageCache.entries())
      const toDelete = entries.slice(0, 20) // Supprimer les 20 plus anciens
      toDelete.forEach(([key]) => imageCache.delete(key))
    }
    // Ne pas nettoyer httpCache - il doit persister pour la navigation
  },

  /**
   * Obtenir les statistiques du cache
   */
  getCacheStats: () => ({
    cacheSize: imageCache.size,
    httpCacheSize: httpCache.size,
    preloadQueue: preloadQueue.size,
    loadingPromises: loadingPromises.size
  }),

  /**
   * Vider le cache
   */
  clearCache: () => {
    imageCache.clear()
    preloadQueue.clear()
    loadingPromises.clear()
    httpCache.clear()
    
    // Vider aussi les caches persistants
    try {
      localStorage.removeItem(PERSISTENT_CACHE_KEY)
      sessionStorage.removeItem(SESSION_CACHE_KEY)
      console.log('üóëÔ∏è Tous les caches vid√©s')
    } catch (error) {
      console.warn('Erreur vidage caches persistants:', error)
    }
  },

  /**
   * Nettoyer le cache ancien (plus de 7 jours)
   */
  cleanupOldCache: () => {
    try {
      const now = Date.now()
      const maxAge = 7 * 24 * 60 * 60 * 1000 // 7 jours
      
      // Nettoyer le cache persistant
      const stored = localStorage.getItem(PERSISTENT_CACHE_KEY)
      if (stored) {
        const data = JSON.parse(stored)
        const filtered = data.filter(([key, value]) => {
          // Garder seulement les URLs r√©centes (logique simplifi√©e)
          return key.includes('w=256&q=75&f=webp')
        })
        
        if (filtered.length !== data.length) {
          localStorage.setItem(PERSISTENT_CACHE_KEY, JSON.stringify(filtered))
          console.log(`üßπ Cache nettoy√©: ${data.length - filtered.length} images supprim√©es`)
        }
      }
    } catch (error) {
      console.warn('Erreur nettoyage cache:', error)
    }
  },

  /**
   * Pr√©charger agressivement toutes les images d'une page (INSTANTAN√â)
   */
  preloadPageImages: async (articles = []) => {
    if (!articles || articles.length === 0) return

    console.log(`üöÄ Pr√©chargement agressif pour ${articles.length} articles`)
    
    const imageUrls = []
    articles.forEach((article, index) => {
      console.log(`üì¶ Article ${index + 1}:`, {
        hasItems: !!article.items,
        itemsLength: article.items?.length || 0,
        hasProductId: !!article.product_id,
        product_id: article.product_id,
        image_url: article.image_url
      })
      
      // V√©rifier si l'article a des items (structure imbriqu√©e)
      if (article.items && Array.isArray(article.items)) {
        article.items.forEach((item, itemIndex) => {
          console.log(`  üìã Item ${itemIndex + 1}:`, {
            product_id: item.product_id,
            hasProductId: !!item.product_id
          })
          
          if (item.product_id) {
            const baseUrl = import.meta.env.DEV 
              ? 'http://localhost:3001' 
              : 'https://maisoncleo-commande.onrender.com'
            const imageUrl = `${baseUrl}/api/images/${item.product_id}?w=256&q=75&f=webp`
            imageUrls.push(imageUrl)
            console.log(`  ‚úÖ URL ajout√©e: ${imageUrl}`)
          }
        })
      } 
      // Sinon, utiliser directement les propri√©t√©s de l'article
      else if (article.product_id) {
        const baseUrl = import.meta.env.DEV 
          ? 'http://localhost:3001' 
          : 'https://maisoncleo-commande.onrender.com'
        const imageUrl = `${baseUrl}/api/images/${article.product_id}?w=256&q=75&f=webp`
        imageUrls.push(imageUrl)
        console.log(`  ‚úÖ URL directe ajout√©e: ${imageUrl}`)
      }
    })
    

    if (imageUrls.length > 0) {
      try {
        console.log(`üîÑ D√©but pr√©chargement de ${imageUrls.length} images...`)
        
        // Pr√©charger par lots de 5 pour √©viter la surcharge
        const batchSize = 5
        const batches = []
        for (let i = 0; i < imageUrls.length; i += batchSize) {
          batches.push(imageUrls.slice(i, i + batchSize))
        }
        
        let totalSuccessful = 0
        let totalFailed = 0
        
        for (let i = 0; i < batches.length; i++) {
          const batch = batches[i]
          console.log(`üì¶ Lot ${i + 1}/${batches.length}: ${batch.length} images`)
          console.log(`üîó URLs du lot:`, batch.map(url => url.split('/').pop()))
          
          const promises = batch.map(url => ImageOptimizationService.preloadImage(url, true))
          const results = await Promise.allSettled(promises)
          const successful = results.filter(r => r.status === 'fulfilled').length
          const failed = results.filter(r => r.status === 'rejected').length
          
          totalSuccessful += successful
          totalFailed += failed
          
          console.log(`‚úÖ Lot ${i + 1} termin√©: ${successful}/${batch.length} images`)
          
          // Afficher le cache apr√®s chaque lot
          const stats = ImageOptimizationService.getCacheStats()
          
          // Petite pause entre les lots pour √©viter la surcharge
          if (i < batches.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 100))
          }
        }
        
        console.log(`‚úÖ Pr√©chargement termin√©: ${totalSuccessful}/${imageUrls.length} images (${totalFailed} √©checs)`)
        
        // Afficher les stats finales du cache
        const finalStats = ImageOptimizationService.getCacheStats()
      } catch (error) {
        console.warn('Erreur pr√©chargement agressif:', error)
      }
    }
  },

  /**
   * Pr√©charger les images des nouvelles commandes apr√®s sync
   */
  preloadNewOrders: async (newOrders = []) => {
    if (!newOrders || newOrders.length === 0) return

    console.log(`üîÑ Pr√©chargement images pour ${newOrders.length} nouvelles commandes`)
    
    const imageUrls = []
    newOrders.forEach(order => {
      if (order.items && Array.isArray(order.items)) {
        order.items.forEach(item => {
          if (item.product_id) {
            const baseUrl = import.meta.env.DEV 
              ? 'http://localhost:3001' 
              : 'https://maisoncleo-commande.onrender.com'
            const imageUrl = `${baseUrl}/api/images/${item.product_id}?w=256&q=75&f=webp`
            imageUrls.push(imageUrl)
          }
        })
      }
    })

    if (imageUrls.length > 0) {
      try {
        await ImageOptimizationService.preloadBatch(imageUrls, true) // Priorit√© haute
        console.log(`‚úÖ Pr√©chargement termin√©: ${imageUrls.length} images`)
      } catch (error) {
        console.warn('Erreur pr√©chargement nouvelles commandes:', error)
      }
    }
  }
}

/**
 * Hook React pour l'optimisation des images
 */
export const useImageOptimization = (urls = [], priority = false) => {
  const [loadedImages, setLoadedImages] = useState(new Map())
  const [isLoading, setIsLoading] = useState(false)

  useEffect(() => {
    if (urls.length === 0) return

    setIsLoading(true)
    
    ImageOptimizationService.preloadBatch(urls, priority)
      .then(results => {
        const loaded = new Map()
        results.forEach((result, index) => {
          if (result.status === 'fulfilled' && result.value) {
            loaded.set(urls[index], result.value)
          }
        })
        setLoadedImages(loaded)
      })
      .catch(error => {
        console.warn('Erreur pr√©chargement batch:', error)
      })
      .finally(() => {
        setIsLoading(false)
      })
  }, [urls, priority])

  return { loadedImages, isLoading }
}

export default ImageOptimizationService

